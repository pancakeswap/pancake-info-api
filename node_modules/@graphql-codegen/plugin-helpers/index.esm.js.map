{"version":3,"file":"index.esm.js","sources":["../../../dist/utils/plugins-helpers/src/resolve-external-module-and-fn.js","../../../dist/utils/plugins-helpers/src/types.js","../../../dist/utils/plugins-helpers/src/utils.js","../../../dist/utils/plugins-helpers/src/helpers.js","../../../dist/utils/plugins-helpers/src/federation.js","../../../dist/utils/plugins-helpers/src/errors.js"],"sourcesContent":["import { paramCase } from 'param-case';\nexport function resolveExternalModuleAndFn(pointer) {\n    // eslint-disable-next-line no-eval\n    const importExternally = (moduleName) => eval(`require('${moduleName}')`);\n    if (typeof pointer === 'function') {\n        return pointer;\n    }\n    // eslint-disable-next-line prefer-const\n    let [moduleName, functionName] = pointer.split('#');\n    // Temp workaround until v2\n    if (moduleName === 'change-case') {\n        moduleName = paramCase(functionName);\n    }\n    const { resolve } = importExternally('path');\n    const localFilePath = resolve(process.cwd(), moduleName);\n    const { existsSync } = importExternally('fs');\n    const localFileExists = existsSync(localFilePath);\n    const importFrom = importExternally('import-from');\n    const loadedModule = localFileExists ? importExternally(localFilePath) : importFrom(process.cwd(), moduleName);\n    if (!(functionName in loadedModule) && typeof loadedModule !== 'function') {\n        throw new Error(`${functionName} couldn't be found in module ${moduleName}!`);\n    }\n    return loadedModule[functionName] || loadedModule;\n}\n//# sourceMappingURL=resolve-external-module-and-fn.js.map","export function isComplexPluginOutput(obj) {\n    return typeof obj === 'object' && obj.hasOwnProperty('content');\n}\n//# sourceMappingURL=types.js.map","import { isListType, isNonNullType } from 'graphql';\nexport function mergeOutputs(content) {\n    const result = { content: '', prepend: [], append: [] };\n    if (Array.isArray(content)) {\n        content.forEach(item => {\n            if (typeof item === 'string') {\n                result.content += item;\n            }\n            else {\n                result.content += item.content;\n                result.prepend.push(...(item.prepend || []));\n                result.append.push(...(item.append || []));\n            }\n        });\n    }\n    return [...result.prepend, result.content, ...result.append].join('\\n');\n}\nexport function isWrapperType(t) {\n    return isListType(t) || isNonNullType(t);\n}\nexport function getBaseType(type) {\n    if (isWrapperType(type)) {\n        return getBaseType(type.ofType);\n    }\n    else {\n        return type;\n    }\n}\n//# sourceMappingURL=utils.js.map","import { visit, isListType, isObjectType, Kind, isNonNullType, } from 'graphql';\nimport { getBaseType } from './utils';\nexport function isOutputConfigArray(type) {\n    return Array.isArray(type);\n}\nexport function isConfiguredOutput(type) {\n    return typeof type === 'object' && type.plugins;\n}\nexport function normalizeOutputParam(config) {\n    // In case of direct array with a list of plugins\n    if (isOutputConfigArray(config)) {\n        return {\n            documents: [],\n            schema: [],\n            plugins: isConfiguredOutput(config) ? config.plugins : config,\n        };\n    }\n    else if (isConfiguredOutput(config)) {\n        return config;\n    }\n    else {\n        throw new Error(`Invalid \"generates\" config!`);\n    }\n}\nexport function normalizeInstanceOrArray(type) {\n    if (Array.isArray(type)) {\n        return type;\n    }\n    else if (!type) {\n        return [];\n    }\n    return [type];\n}\nexport function normalizeConfig(config) {\n    if (typeof config === 'string') {\n        return [{ [config]: {} }];\n    }\n    else if (Array.isArray(config)) {\n        return config.map(plugin => (typeof plugin === 'string' ? { [plugin]: {} } : plugin));\n    }\n    else if (typeof config === 'object') {\n        return Object.keys(config).reduce((prev, pluginName) => [...prev, { [pluginName]: config[pluginName] }], []);\n    }\n    else {\n        return [];\n    }\n}\nexport function hasNullableTypeRecursively(type) {\n    if (!isNonNullType(type)) {\n        return true;\n    }\n    if (isListType(type) || isNonNullType(type)) {\n        return hasNullableTypeRecursively(type.ofType);\n    }\n    return false;\n}\nexport function isUsingTypes(document, externalFragments, schema) {\n    let foundFields = 0;\n    const typesStack = [];\n    visit(document, {\n        SelectionSet: {\n            enter(node, key, parent, anscestors) {\n                const insideIgnoredFragment = anscestors.find((f) => f.kind && f.kind === 'FragmentDefinition' && externalFragments.includes(f.name.value));\n                if (insideIgnoredFragment) {\n                    return;\n                }\n                const selections = node.selections || [];\n                if (schema && selections.length > 0) {\n                    const nextTypeName = (() => {\n                        if (parent.kind === Kind.FRAGMENT_DEFINITION) {\n                            return parent.typeCondition.name.value;\n                        }\n                        else if (parent.kind === Kind.FIELD) {\n                            const lastType = typesStack[typesStack.length - 1];\n                            if (!lastType) {\n                                throw new Error(`Unable to find parent type! Please make sure you operation passes validation`);\n                            }\n                            const field = lastType.getFields()[parent.name.value];\n                            if (!field) {\n                                throw new Error(`Unable to find field \"${parent.name.value}\" on type \"${lastType}\"!`);\n                            }\n                            return getBaseType(field.type).name;\n                        }\n                        else if (parent.kind === Kind.OPERATION_DEFINITION) {\n                            if (parent.operation === 'query') {\n                                return schema.getQueryType().name;\n                            }\n                            else if (parent.operation === 'mutation') {\n                                return schema.getMutationType().name;\n                            }\n                            else if (parent.operation === 'subscription') {\n                                return schema.getSubscriptionType().name;\n                            }\n                        }\n                        else if (parent.kind === Kind.INLINE_FRAGMENT && parent.typeCondition) {\n                            return parent.typeCondition.name.value;\n                        }\n                        return null;\n                    })();\n                    typesStack.push(schema.getType(nextTypeName));\n                }\n            },\n            leave(node) {\n                const selections = node.selections || [];\n                if (schema && selections.length > 0) {\n                    typesStack.pop();\n                }\n            },\n        },\n        Field: {\n            enter: (node, key, parent, path, anscestors) => {\n                if (node.name.value.startsWith('__')) {\n                    return;\n                }\n                const insideIgnoredFragment = anscestors.find((f) => f.kind && f.kind === 'FragmentDefinition' && externalFragments.includes(f.name.value));\n                if (insideIgnoredFragment) {\n                    return;\n                }\n                const selections = node.selectionSet ? node.selectionSet.selections || [] : [];\n                const relevantFragmentSpreads = selections.filter(s => s.kind === Kind.FRAGMENT_SPREAD && !externalFragments.includes(s.name.value));\n                if (selections.length === 0 || relevantFragmentSpreads.length > 0) {\n                    foundFields++;\n                }\n                if (schema) {\n                    const lastType = typesStack[typesStack.length - 1];\n                    if (lastType) {\n                        if (isObjectType(lastType)) {\n                            const field = lastType.getFields()[node.name.value];\n                            if (!field) {\n                                throw new Error(`Unable to find field \"${node.name.value}\" on type \"${lastType}\"!`);\n                            }\n                            const currentType = field.type;\n                            // To handle `Maybe` usage\n                            if (hasNullableTypeRecursively(currentType)) {\n                                foundFields++;\n                            }\n                        }\n                    }\n                }\n            },\n        },\n        enter: {\n            VariableDefinition: (node, key, parent, path, anscestors) => {\n                const insideIgnoredFragment = anscestors.find((f) => f.kind && f.kind === 'FragmentDefinition' && externalFragments.includes(f.name.value));\n                if (insideIgnoredFragment) {\n                    return;\n                }\n                foundFields++;\n            },\n            InputValueDefinition: (node, key, parent, path, anscestors) => {\n                const insideIgnoredFragment = anscestors.find((f) => f.kind && f.kind === 'FragmentDefinition' && externalFragments.includes(f.name.value));\n                if (insideIgnoredFragment) {\n                    return;\n                }\n                foundFields++;\n            },\n        },\n    });\n    return foundFields > 0;\n}\n//# sourceMappingURL=helpers.js.map","import { parse, GraphQLObjectType, isObjectType, isNonNullType, printType, Kind, } from 'graphql';\nimport { getBaseType } from './utils';\n/**\n * Federation Spec\n */\nexport const federationSpec = parse(/* GraphQL */ `\n  scalar _FieldSet\n\n  directive @external on FIELD_DEFINITION\n  directive @requires(fields: _FieldSet!) on FIELD_DEFINITION\n  directive @provides(fields: _FieldSet!) on FIELD_DEFINITION\n  directive @key(fields: _FieldSet!) on OBJECT | INTERFACE\n`);\n/**\n * Adds `__resolveReference` in each ObjectType involved in Federation.\n * @param schema\n */\nexport function addFederationReferencesToSchema(schema) {\n    const typeMap = schema.getTypeMap();\n    for (const typeName in typeMap) {\n        const type = schema.getType(typeName);\n        if (isObjectType(type) && isFederationObjectType(type)) {\n            const typeConfig = type.toConfig();\n            typeConfig.fields = {\n                [resolveReferenceFieldName]: {\n                    type,\n                },\n                ...typeConfig.fields,\n            };\n            const newType = new GraphQLObjectType(typeConfig);\n            newType.astNode = newType.astNode || parse(printType(newType)).definitions[0];\n            newType.astNode.fields.unshift({\n                kind: Kind.FIELD_DEFINITION,\n                name: {\n                    kind: Kind.NAME,\n                    value: resolveReferenceFieldName,\n                },\n                type: {\n                    kind: Kind.NAMED_TYPE,\n                    name: {\n                        kind: Kind.NAME,\n                        value: typeName,\n                    },\n                },\n            });\n            typeMap[typeName] = newType;\n        }\n    }\n    return schema;\n}\n/**\n * Removes Federation Spec from GraphQL Schema\n * @param schema\n * @param config\n */\nexport function removeFederation(schema) {\n    const queryType = schema.getQueryType();\n    const queryTypeFields = queryType.getFields();\n    delete queryTypeFields._entities;\n    delete queryTypeFields._service;\n    const typeMap = schema.getTypeMap();\n    delete typeMap._Service;\n    delete typeMap._Entity;\n    delete typeMap._Any;\n    return schema;\n}\nconst resolveReferenceFieldName = '__resolveReference';\nexport class ApolloFederation {\n    constructor({ enabled, schema }) {\n        this.enabled = false;\n        this.enabled = enabled;\n        this.schema = schema;\n        this.providesMap = this.createMapOfProvides();\n    }\n    /**\n     * Excludes types definde by Federation\n     * @param typeNames List of type names\n     */\n    filterTypeNames(typeNames) {\n        return this.enabled ? typeNames.filter(t => t !== '_FieldSet') : typeNames;\n    }\n    /**\n     * Excludes `__resolveReference` fields\n     * @param fieldNames List of field names\n     */\n    filterFieldNames(fieldNames) {\n        return this.enabled ? fieldNames.filter(t => t !== resolveReferenceFieldName) : fieldNames;\n    }\n    /**\n     * Decides if directive should not be generated\n     * @param name directive's name\n     */\n    skipDirective(name) {\n        return this.enabled && ['external', 'requires', 'provides', 'key'].includes(name);\n    }\n    /**\n     * Decides if scalar should not be generated\n     * @param name directive's name\n     */\n    skipScalar(name) {\n        return this.enabled && name === '_FieldSet';\n    }\n    /**\n     * Decides if field should not be generated\n     * @param data\n     */\n    skipField({ fieldNode, parentType }) {\n        if (!this.enabled || !isObjectType(parentType) || !isFederationObjectType(parentType)) {\n            return false;\n        }\n        return this.isExternalAndNotProvided(fieldNode, parentType);\n    }\n    isResolveReferenceField(fieldNode) {\n        const name = typeof fieldNode.name === 'string' ? fieldNode.name : fieldNode.name.value;\n        return this.enabled && name === resolveReferenceFieldName;\n    }\n    /**\n     * Transforms ParentType signature in ObjectTypes involved in Federation\n     * @param data\n     */\n    transformParentType({ fieldNode, parentType, parentTypeSignature, }) {\n        if (this.enabled &&\n            isObjectType(parentType) &&\n            isFederationObjectType(parentType) &&\n            fieldNode.name.value === resolveReferenceFieldName) {\n            const keys = getDirectivesByName('key', parentType);\n            if (keys.length) {\n                const outputs = [`{ __typename: '${parentType.name}' } &`];\n                // Look for @requires and see what the service needs and gets\n                const requires = getDirectivesByName('requires', fieldNode)\n                    .map(this.extractFieldSet)\n                    .reduce((prev, curr) => [...prev, ...curr], [])\n                    .map(name => {\n                    return { name, required: isNonNullType(parentType.getFields()[name].type) };\n                });\n                const requiredFields = this.translateFieldSet(requires, parentTypeSignature);\n                // @key() @key() - \"primary keys\" in Federation\n                const primaryKeys = keys.map(def => {\n                    const fields = this.extractFieldSet(def).map(name => ({ name, required: true }));\n                    return this.translateFieldSet(fields, parentTypeSignature);\n                });\n                const [open, close] = primaryKeys.length > 1 ? ['(', ')'] : ['', ''];\n                outputs.push([open, primaryKeys.join(' | '), close].join(''));\n                // include required fields\n                if (requires.length) {\n                    outputs.push(`& ${requiredFields}`);\n                }\n                return outputs.join(' ');\n            }\n        }\n        return parentTypeSignature;\n    }\n    isExternalAndNotProvided(fieldNode, objectType) {\n        return this.isExternal(fieldNode) && !this.hasProvides(objectType, fieldNode);\n    }\n    isExternal(node) {\n        return getDirectivesByName('external', node).length > 0;\n    }\n    hasProvides(objectType, node) {\n        const fields = this.providesMap[isObjectType(objectType) ? objectType.name : objectType.name.value];\n        if (fields && fields.length) {\n            return fields.includes(node.name.value);\n        }\n        return false;\n    }\n    translateFieldSet(fields, parentTypeRef) {\n        // TODO: support other things than fields separated by a whitespace (fields: \"fieldA fieldB fieldC\")\n        const keys = fields.map(field => `'${field.name}'`).join(' | ');\n        return `Pick<${parentTypeRef}, ${keys}>`;\n    }\n    extractFieldSet(directive) {\n        const arg = directive.arguments.find(arg => arg.name.value === 'fields');\n        const value = arg.value.value;\n        if (/[{}]/gi.test(value)) {\n            throw new Error('Nested fields in _FieldSet is not supported');\n        }\n        return deduplicate(value.split(/\\s+/g));\n    }\n    createMapOfProvides() {\n        const providesMap = {};\n        Object.keys(this.schema.getTypeMap()).forEach(typename => {\n            const objectType = this.schema.getType(typename);\n            if (isObjectType(objectType)) {\n                Object.values(objectType.getFields()).forEach(field => {\n                    const provides = getDirectivesByName('provides', field.astNode)\n                        .map(this.extractFieldSet)\n                        .reduce((prev, curr) => [...prev, ...curr], []);\n                    const ofType = getBaseType(field.type);\n                    if (!providesMap[ofType.name]) {\n                        providesMap[ofType.name] = [];\n                    }\n                    providesMap[ofType.name].push(...provides);\n                });\n            }\n        });\n        return providesMap;\n    }\n}\n/**\n * Checks if Object Type is involved in Federation. Based on `@key` directive\n * @param node Type\n */\nfunction isFederationObjectType(node) {\n    const definition = isObjectType(node)\n        ? node.astNode || parse(printType(node)).definitions[0]\n        : node;\n    const name = definition.name.value;\n    const directives = definition.directives;\n    const isNotRoot = !['Query', 'Mutation', 'Subscription'].includes(name);\n    const isNotIntrospection = !name.startsWith('__');\n    const hasKeyDirective = directives.some(d => d.name.value === 'key');\n    return isNotRoot && isNotIntrospection && hasKeyDirective;\n}\nfunction deduplicate(items) {\n    return items.filter((item, i) => items.indexOf(item) === i);\n}\n/**\n * Extracts directives from a node based on directive's name\n * @param name directive name\n * @param node ObjectType or Field\n */\nfunction getDirectivesByName(name, node) {\n    let astNode;\n    if (isObjectType(node)) {\n        astNode = node.astNode;\n    }\n    else {\n        astNode = node;\n    }\n    if (astNode && astNode.directives) {\n        return astNode.directives.filter(d => d.name.value === name);\n    }\n    return [];\n}\n//# sourceMappingURL=federation.js.map","export class DetailedError extends Error {\n    constructor(message, details, source) {\n        super(message);\n        this.message = message;\n        this.details = details;\n        this.source = source;\n        Object.setPrototypeOf(this, DetailedError.prototype);\n        Error.captureStackTrace(this, DetailedError);\n    }\n}\nexport function isDetailedError(error) {\n    return error.details;\n}\n//# sourceMappingURL=errors.js.map"],"names":[],"mappings":"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"}